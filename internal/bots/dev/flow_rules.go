package dev

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/bytedance/sonic"
	"github.com/flowline-io/flowbot/pkg/flows"
	"github.com/flowline-io/flowbot/pkg/types"
	"github.com/flowline-io/flowbot/pkg/types/ruleset/action"
	"github.com/flowline-io/flowbot/pkg/types/ruleset/trigger"
	"github.com/tidwall/gjson"
)

// TriggerRules and ActionRules are development-friendly examples intended for flow testing.
// They are registered as rulesets under the "dev" bot.
var TriggerRules = []trigger.Rule{
	{
		Id:          "manual",
		Title:       "Manual",
		Description: "Manually execute a flow.",
		Mode:        trigger.ModeManual,
		Abstraction: trigger.AbstractionObject,
		Extract: func(_ types.Context, _ types.KV, payload types.KV) (types.KV, error) {
			return types.KV{"payload": payload}, nil
		},
	},
	{
		Id:          "webhook",
		Title:       "Webhook",
		Description: "Receive an incoming webhook to trigger a flow.",
		Mode:        trigger.ModeWebhook,
		Abstraction: trigger.AbstractionObject,
		Config: func(_ types.KV) error {
			// token is generated by server if missing
			return nil
		},
		Extract: func(_ types.Context, params types.KV, payload types.KV) (types.KV, error) {
			out := types.KV{"payload": payload}

			var ingredients []flows.Ingredient
			if raw, ok := params["ingredients"]; ok {
				b, _ := sonic.Marshal(raw)
				_ = sonic.Unmarshal(b, &ingredients)
			}
			if len(ingredients) == 0 {
				return out, nil
			}
			vars, err := flows.ExtractIngredients(payload, nil, ingredients)
			if err != nil {
				return nil, err
			}
			return out.Merge(vars), nil
		},
	},
	{
		Id:          "http_poll",
		Title:       "HTTP JSON Poll",
		Description: "Poll an HTTP JSON endpoint and trigger on new items or status transitions.",
		Mode:        trigger.ModePoll,
		Abstraction: trigger.AbstractionTransition,
		Config: func(_ types.KV) error {
			return nil
		},
		Extract: func(_ types.Context, params types.KV, payload types.KV) (types.KV, error) {
			out := types.KV{"payload": payload}
			var ingredients []flows.Ingredient
			if raw, ok := params["ingredients"]; ok {
				b, _ := sonic.Marshal(raw)
				_ = sonic.Unmarshal(b, &ingredients)
			}
			item := payload["item"]
			vars, err := flows.ExtractIngredients(payload, item, ingredients)
			if err != nil {
				return nil, err
			}
			return out.Merge(vars), nil
		},
		Poll: func(ctx types.Context, params types.KV, state types.KV) (trigger.PollResult, error) {
			url, _ := params.String("url")
			if strings.TrimSpace(url) == "" {
				return trigger.PollResult{}, errors.New("url is required")
			}
			itemsPath, _ := params.String("items_path")
			if strings.TrimSpace(itemsPath) == "" {
				return trigger.PollResult{}, errors.New("items_path is required")
			}
			idPath, _ := params.String("id_path")
			if strings.TrimSpace(idPath) == "" {
				return trigger.PollResult{}, errors.New("id_path is required")
			}
			statusPath, _ := params.String("status_path")
			fromStatus, _ := params.String("from_status")
			toStatus, _ := params.String("to_status")

			method, _ := params.String("method")
			if strings.TrimSpace(method) == "" {
				method = http.MethodGet
			}

			req, err := http.NewRequestWithContext(ctx.Context(), method, url, nil)
			if err != nil {
				return trigger.PollResult{}, err
			}
			if hdrs, ok := params.Map("headers"); ok {
				for k, v := range hdrs {
					req.Header.Set(k, toString(v))
				}
			}

			client := &http.Client{Timeout: 30 * time.Second}
			resp, err := client.Do(req)
			if err != nil {
				return trigger.PollResult{}, err
			}
			defer resp.Body.Close()
			body, err := io.ReadAll(resp.Body)
			if err != nil {
				return trigger.PollResult{}, err
			}
			if resp.StatusCode < 200 || resp.StatusCode >= 300 {
				return trigger.PollResult{}, fmt.Errorf("http status %d", resp.StatusCode)
			}

			rootJSON := string(body)
			items := gjson.Get(rootJSON, itemsPath)
			if !items.Exists() || !items.IsArray() {
				return trigger.PollResult{}, fmt.Errorf("items_path '%s' must be an array", itemsPath)
			}

			last := map[string]string{}
			if m, ok := state.Map("last"); ok {
				for k, v := range m {
					last[k] = toString(v)
				}
			}

			nextLast := map[string]string{}
			var events []types.KV
			for _, item := range items.Array() {
				id := gjson.Get(item.Raw, idPath)
				if !id.Exists() {
					continue
				}
				idStr := id.String()
				if idStr == "" {
					idStr = strings.TrimSpace(id.Raw)
				}
				if idStr == "" {
					continue
				}

				newStatus := ""
				if strings.TrimSpace(statusPath) != "" {
					st := gjson.Get(item.Raw, statusPath)
					if st.Exists() {
						newStatus = st.String()
					}
				}
				nextLast[idStr] = newStatus

				oldStatus, had := last[idStr]
				shouldFire := false
				if strings.TrimSpace(statusPath) == "" {
					shouldFire = !had
				} else {
					if !had {
						shouldFire = true
					} else if oldStatus != newStatus {
						shouldFire = true
					}
					if fromStatus != "" || toStatus != "" {
						if !(oldStatus == fromStatus && newStatus == toStatus) {
							shouldFire = false
						}
					}
				}
				if !shouldFire {
					continue
				}

				var itemObj any
				_ = sonic.Unmarshal([]byte(item.Raw), &itemObj)
				ev := types.KV{
					"id":     idStr,
					"item":   itemObj,
					"before": oldStatus,
					"after":  newStatus,
				}
				events = append(events, ev)
			}

			newState := make(types.KV)
			for k, v := range state {
				newState[k] = v
			}
			lastObj := make(map[string]any, len(nextLast))
			for k, v := range nextLast {
				lastObj[k] = v
			}
			newState["last"] = lastObj

			return trigger.PollResult{Events: events, State: newState}, nil
		},
	},
}

var ActionRules = []action.Rule{
	{
		Id:          "echo",
		Title:       "Echo",
		Description: "Return provided params after template substitution.",
		Inputs: []flows.ParamSpec{
			{Name: "text", Type: flows.ParamTypeString, Required: true, Description: "Text to echo"},
		},
		Run: func(_ types.Context, params types.KV, _ types.KV) (types.KV, error) {
			return types.KV{"text": params["text"]}, nil
		},
	},
	{
		Id:          "http_webhook",
		Title:       "HTTP Webhook",
		Description: "Send an HTTP request with optional JSON body.",
		Inputs: []flows.ParamSpec{
			{Name: "method", Type: flows.ParamTypeString, Required: true, Description: "HTTP method", Enum: []string{"GET", "POST", "PUT", "PATCH", "DELETE"}},
			{Name: "url", Type: flows.ParamTypeString, Required: true, Description: "Request URL"},
			{Name: "body", Type: flows.ParamTypeObject, Required: false, Description: "JSON body"},
		},
		Run: func(ctx types.Context, params types.KV, _ types.KV) (types.KV, error) {
			method, _ := params.String("method")
			url, _ := params.String("url")
			var bodyBytes []byte
			if body, ok := params["body"]; ok {
				bodyBytes, _ = sonic.Marshal(body)
			}

			req, err := http.NewRequestWithContext(ctx.Context(), method, url, nil)
			if err != nil {
				return nil, err
			}
			if len(bodyBytes) > 0 {
				req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
				req.ContentLength = int64(len(bodyBytes))
				req.Header.Set("Content-Type", "application/json")
			}
			client := &http.Client{Timeout: 30 * time.Second}
			resp, err := client.Do(req)
			if err != nil {
				return nil, err
			}
			defer resp.Body.Close()
			return types.KV{"status": resp.StatusCode}, nil
		},
	},
}

func toString(v any) string {
	switch t := v.(type) {
	case string:
		return t
	default:
		b, err := sonic.Marshal(t)
		if err == nil {
			return strings.Trim(string(b), "\"")
		}
		return ""
	}
}
